---
title: События
description: Руководство по использование событий предоставляемых Fabric API.
authors:
  - dicedpixels
  - mkpoli
  - daomephsta
  - solidblock
  - draylar
  - jamieswhiteshirt
  - PhoenixVX
  - Juuxel
  - YanisBft
  - liach
  - natanfudge
authors-nogithub:
  - stormyfabric
---

# События {#events}

Fabric API предоставляет систему, которая позволяет модам реагировать на действия или явления, так же известные как _события_, происходящие в игре.

События — это хуки, которые удовлетворяют общим сценариям использования и/или обеспечивают улучшенную совместимость и производительность между модами, которые подключаются к одним и тем же областям кода. Использование событий часто заменяет использование mixins.

API Fabric предоставляет события для важных областей кодовой базы Minecraft, в которых могут быть заинтересованы многие разработчики модов.

События представлены экземплярами `net.fabricmc.fabric.api.event.Event`, которые хранят и вызывают _обртный вызов (callback)_. Часто для обратного вызова существует один экземпляр события, который хранится в статическом поле `EVENT` интерфейса обратного вызова, но существуют и другие шаблоны. Например, `ClientTickEvents` группирует несколько связанных событий вместе.

## Обратные вызовы {#callbacks}

Обратный вызов — это фрагмент кода, который передается в качестве аргумента событию. Когда игра инициирует событие, переданный фрагмент кода будет выполнен.

### Интерфейсы обратных вызовов {#callback-interfaces}

Каждое событие имеет соответствующий интерфейс обратного вызова, условно называемый `<EventName>Callback`. Обратные вызовы регистрируются путем вызова метода `register()` для экземпляра события с экземпляром интерфейса обратного вызова в качестве аргумента.

Все интерфейсы обратного вызова событий, предоставляемые Fabric API, можно найти в пакете `net.fabricmc.fabric.api.event`.

## Прослушивание событий {#listening-to-events}

В этом примере регистрируется `AttackBlockCallback` для нанесения урона игроку при столкновении с блоками, из которых не выпадает предмет при ручной добыче.

@[code lang=java transcludeWith=:::1](@/reference/1.21/src/main/java/com/example/docs/event/FabricDocsReferenceEvents.java)

### Добавление предмета к существующим таблицам лута {#adding-items-to-existing-loot-tables}

Иногда вам может понадобиться добавить предметы в таблицы добычи. Например, добавляя свои капли в ванильный блок или сущность.

Самое простое решение — замена файла таблицы добычи — это может сломать другие моды. А что, если они захотят изменить и их? Мы рассмотрим, как можно добавлять предметы в таблицы добычи, не переопределяя таблицу.

Мы добавим особый элемент в таблицу лута угольной руды.

#### Прослушивание загрузки таблицы добычи {#listening-to-loot-table-loading}

В API Fabric есть событие, которое запускается при загрузке таблиц добычи, `LootTableEvents.MODIFY`. Вы можете зарегистрировать обратный вызов для него в инициализаторе мода. Давайте также проверим, что текущая таблица добычи — это таблица добычи угольной руды.

@[code lang=java transclude={38-40}](@/reference/1.21/src/main/java/com/example/docs/event/FabricDocsReferenceEvents.java)

#### Добавление предметов в таблицу добычи {#adding-items-to-the-loot-table}

В таблицах лута предметы хранятся в _элементах лут пулов, а элементы хранятся в _лут пулах_. Чтобы добавить предмет, нам нужно добавить пул с записью предмета в таблицу добычи.

Мы можем создать пул с помощью `LootPool#builder` и добавить его в таблицу добычи.

В нашем пуле также нет элементов, поэтому мы создадим запись элемента с помощью `ItemEntry#builder` и добавим ее в пул.

@[code highlight={6-7} transcludeWith=:::2](@/reference/1.21/src/main/java/com/example/docs/event/FabricDocsReferenceEvents.java)

## Собственные события {#custom-events}

В некоторых областях игры отсутствуют хуки, предоставляемые API Fabric, поэтому вы можете либо использовать mixin, либо создать собственное событие.

Мы рассмотрим создание события, которое запускается при стрижке овец. Процесс создания события:

- Создание интерфейса обратного вызова события
- Запуск события из mixin
- Создание тестовой реализации

### Создание интерфейса обратного вызова {#creating-the-event-callback-interface}

Интерфейс обратного вызова описывает, что должно быть реализовано слушателем событий, которые будут прослушивать ваше событие. Интерфейс обратного вызова также описывает, как событие будет вызываться из нашего mixin. Традиционно, объект `Event` помещают в качестве поля в интерфейс обратного вызова, который будет идентифицировать наше фактическое событие.

Для нашей реализации `Event` мы выберем использование события на основе массива. Массив будет содержать все слушатели событий, которые прослушивают событие.

Наша реализация будет вызывать слушатели событий по порядку до тех пор, пока один из них не вернет `ActionResult.PASS`. Это означает, что слушатель может сказать «_отменить это_», «_одобрить это_» или «_неважно, оставьте это следующему слушателю событий_», используя возвращаемое значение.

Использование `ActionResult` в качестве возвращаемого значения — это общепринятый способ заставить обработчики событий взаимодействовать таким образом.

Вам необходимо создать интерфейс, имеющий экземпляр «События» и метод для реализации ответа. Базовая настройка обратного вызова для стрижки овец выглядит следующим образом:

@[code lang=java transcludeWith=:::](@/reference/1.21/src/main/java/com/example/docs/event/SheepShearCallback.java)

Давайте рассмотрим это более подробно. При вызове мы перебираем всех слушателей:

@[code lang=java transclude={21-22}](@/reference/1.21/src/main/java/com/example/docs/event/SheepShearCallback.java)

Затем мы вызываем наш метод (в данном случае `interact`) для слушателя, чтобы получить его ответ:

@[code lang=java transclude={33-33}](@/reference/1.21/src/main/java/com/example/docs/event/SheepShearCallback.java)

Если слушатель сообщает, что нам необходимо отменить (`ActionResult.FAIL`) или завершить (`ActionResult.SUCCESS`), обратный вызов возвращает результат и завершает цикл. `ActionResult.PASS` переходит к следующему слушателю и в большинстве случаев должен завершиться успешно, если больше нет зарегистрированных слушателей:

@[code lang=java transclude={25-30}](@/reference/1.21/src/main/java/com/example/docs/event/SheepShearCallback.java)

Мы можем добавить комментарии Javadoc в начало классов обратного вызова, чтобы документировать, что делает каждый `ActionResult`. В нашем случае это может быть:

@[code lang=java transclude={9-16}](@/reference/1.21/src/main/java/com/example/docs/event/SheepShearCallback.java)

### Запуск события из Mixin'а {#triggering-the-event-from-a-mixin}

Теперь у нас есть базовый скелет события, но нам нужно его запустить. Поскольку мы хотим, чтобы событие вызывалось, когда игрок пытается постричь овцу, мы вызываем событие `invoker` в `SheepEntity#interactMob`, когда вызывается `sheared()` (т. е. овцу можно стричь, а игрок держит ножницы):

@[code lang=java transcludeWith=:::](@/reference/1.21/src/main/java/com/example/docs/mixin/event/SheepEntityMixin.java)

### Создание тестовой имплементации {#creating-a-test-implementation}

Теперь нам нужно протестировать наше событие. Вы можете зарегистрировать слушатель в своем методе инициализации (или в другой области, если вам так удобнее) и добавить туда пользовательскую логику. Вот пример, в котором вместо шерсти к ногам овцы падает алмаз:

@[code lang=java transcludeWith=:::3](@/reference/1.21/src/main/java/com/example/docs/event/FabricDocsReferenceEvents.java)

Если вы зайдете в игру и пострижете овцу, вместо шерсти должен выпасть алмаз.
