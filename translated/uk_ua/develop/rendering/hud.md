---
title: Промальовування у HUD
description: Узнайте як використовувати API Fabric Hud для промальовування у HUD.
authors:
  - IMB11
  - kevinthegreat1
---

Ми вже коротко торкалися промальовування речей у HUD на сторінці [основні концепції промальовування](./basic-concepts) та [використання контексту малювання](./draw-context), тому на цій сторінці ми будемо дотримуватись API Hud і параметра `RenderTickCounter`.

## `HudRenderCallback` {#hudrendercallback}

:::warning
Раніше Fabric надавав `HudRenderCallback` для промальовування в HUD. Через зміни у промальовуванні HUD ця подія стала надзвичайно обмеженою та не підтримується після Fabric API 0.116. Використання настійно не рекомендується.
:::

## `HudLayerRegistrationCallback` {#hudlayerregistrationcallback}

Fabric надає API Hud для промальовування та накладення елементів на HUD.

Для початку нам потрібно зареєструвати слухача `HudLayerRegistrationCallback`, який реєструє ваші шари. Кожен шар є `IdentifiedLayer`, який є ванілльним `LayeredDrawer.Layer` з прикріпленим `Identifier`. Екземпляр `LayeredDrawer.Layer` зазвичай є лямбда-виразкою, яка приймає екземпляри `DrawContext` і `RenderTickCounter` як параметри. Перегляньте `HudLayerRegistrationCallback` і пов’язані Javadocs, щоб дізнатися більше про те, як використовувати API.

Контекст малювання можна використовувати для доступу до різноманітних утиліт промальовування, які надає гра, і доступу до стеку необроблених матриць. Перегляньте сторінку [контекст малювання](./draw-context), щоб дізнатися більше про контекст малювання.

### Промальовування лічильника тактів {#render-tick-counter}

Клас `RenderTickCounter` дозволяє отримати поточне значення `tickDelta`. Клас `RenderTickCounter` дозволяє отримати поточне значення `tickDelta`.

Наприклад, якщо ми припустимо сценарій 200 FPS, гра запускає новий такт приблизно кожні 10 кадрів. Кожен кадр, `tickDelta`, представляє, наскільки ми знаходимося між останнім тактом і наступним. Понад 11 кадрів ви можете побачити:

| Кадр | `tickDelta`                     |
| :--: | ------------------------------- |
|  `1` | `1`: Новий такт |
|  `2` | `1/10 = 0.1`                    |
|  `3` | `2/10 = 0.2`                    |
|  `4` | `3/10 = 0.3`                    |
|  `5` | `4/10 = 0.4`                    |
|  `6` | `5/10 = 0.5`                    |
|  `7` | `6/10 = 0.6`                    |
|  `8` | `7/10 = 0.7`                    |
|  `9` | `8/10 = 0.8`                    |
| `10` | `9/10 = 0.9`                    |
| `11` | `1`: Новий такт |

На практиці ви повинні використовувати `tickDelta` лише тоді, коли ваші анімації залежать від галочок Minecraft. Для анімації на основі часу використовуйте `Util.getMeasuringTimeMs()`, який вимірює реальний час.

Ви можете отримати `tickDelta`, викликавши `renderTickCounter.getTickDelta(false)`, де логічним параметром є `ignoreFreeze`, що, по суті, дозволяє вам просто ігнорувати, коли гравці використовують команду `/tick freeze`.

Ви можете отримати `tickDelta` за допомогою функції `renderTickCounter.getTickDelta(false);`, де логічним параметром є `ignoreFreeze`, що, по суті, дозволяє вам просто ігнорувати, коли гравці використовують команду `/tick freeze`.

@[code lang=java transcludeWith=:::1](@/reference/latest/src/client/java/com/example/docs/rendering/HudRenderingEntrypoint.java)

![Зміна кольору з часом](/assets/develop/rendering/hud-rendering-deltatick.webp)

Чому б вам не спробувати використати `tickDelta` і подивитися, що відбувається з анімацією, коли ви виконуєте команду `/tick freeze`? Ви повинні побачити зависання анімації, коли `tickDelta` стане постійним (припустимо, що ви передали `false` як параметр для `RenderTickCounter#getTickDelta`)
