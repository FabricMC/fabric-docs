---
title: Промальовування в HUD
description: Давайте-но навчімося використовувати подію HudRenderCallback для промальовування у HUD.
authors:
  - IMB11
---

Ми вже коротко торкалися промальовування речей у hud на сторінці [основних концепцій промальовування](./basic-concepts) і [використання контексту малювання](./draw-context), тому на цій сторінці ми дотримуватимемося події `HudRenderCallback` і параметра `tickDelta`.

## HudRenderCallback {#hudrendercallback}

Подія `HudRenderCallback`, надана API Fabric, викликається в кожному кадрі та використовується для промальовування речей у HUD.

Подія `HudRenderCallback`, надана API Fabric, викликається в кожному кадрі та використовується для промальовування речей у HUD.

Щоб зареєструватися на цю подію, ви можете просто викликати `HudRenderCallback.EVENT.register` і передати лямбда-вираз, який приймає екземпляри `DrawContext` і `RenderTickCounter` як параметри.

Контекст малювання можна використовувати для доступу до різноманітних утиліт промальовування, які надає гра, і доступу до стеку необроблених матриць.

### Промальовування лічильника тактів {#render-tick-counter}

Клас `RenderTickCounter` дозволяє отримати поточне значення `tickDelta`.

Клас `RenderTickCounter` дозволяє отримати поточне значення `tickDelta`.

Наприклад, якщо ми припустимо сценарій 200 FPS, гра запускає новий такт приблизно кожні 10 кадрів. Кожен кадр, `tickDelta`, представляє, наскільки ми знаходимося між останнім тактом і наступним. Понад 10 кадрів ви можете побачити:

| Кадр | tickDelta                       |
| :--: | ------------------------------- |
|  `1` | `1`: Новий такт |
|  `2` | `1/9 ~ 0.11`                    |
|  `3` | `2/9 ~ 0.22`                    |
|  `4` | `3/9 ~ 0.33`                    |
|  `5` | `4/9 ~ 0.44`                    |
|  `6` | `5/9 ~ 0.55`                    |
|  `7` | `6/9 ~ 0.66`                    |
|  `8` | `7/9 ~ 0.77`                    |
|  `9` | `8/9 ~ 0.88`                    |
| `10` | `1`: Новий такт |

На практиці ви повинні використовувати `tickDelta` лише тоді, коли ваша анімація залежить від тактів Minecraft. Для анімації на основі часу використовуйте `Util.getMeasuringTimeMs()`, який вимірює реальний час.

Ви можете отримати `tickDelta` за допомогою функції `renderTickCounter.getTickDelta(false);`, де логічним параметром є `ignoreFreeze`, що, по суті, дозволяє вам просто ігнорувати, коли гравці використовують команду `/tick freeze`.

Ви можете отримати `tickDelta` за допомогою функції `renderTickCounter.getTickDelta(false);`, де логічним параметром є `ignoreFreeze`, що, по суті, дозволяє вам просто ігнорувати, коли гравці використовують команду `/tick freeze`.

@[code lang=java transcludeWith=:::1](@/reference/latest/src/client/java/com/example/docs/rendering/HudRenderingEntrypoint.java)

![Зміна кольору з часом](/assets/develop/rendering/hud-rendering-deltatick.webp)

Чому б вам не спробувати використати `tickDelta` і подивитися, що відбувається з анімацією, коли ви виконуєте команду `/tick freeze`? Ви повинні побачити зависання анімації, коли `tickDelta` стане постійним (припустимо, що ви передали `false` як параметр для `RenderTickCounter#getTickDelta`)
