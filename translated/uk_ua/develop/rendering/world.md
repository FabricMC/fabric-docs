---
title: Рендер у світі
description: Створіть та використовуйте власний конвеєр рендера коли стандартні конвеєри не підходять.
authors:
  - AzureAaron
  - kevinthegreat1
---

<!---->

:::info ПЕРЕДУМОВИ

Переконайтеся, що ви спочатку прочитали [концепції рендера](./basic-concepts). Ця сторінка базується на цих концепціях і обговорює, як рендеряться об’єкти у світі.

На цій сторінці розглядаються деякі більш сучасні концепції рендера. Ви дізнаєтеся більше про дві розділені фази рендера: «вилучення» (або «підготовка») і «малювання» (або «рендер»). У цьому посібнику ми будемо називати фазу «вилучення/підготовки» фазою «вилучення», а фазу «малювання/рендера» — фазою «малювання».

:::

Щоб рендерити власні об'єкти у світі, у вас є два варіанти. Ви можете вставити в наявний стандартний рендер та додати свій код, але це обмежує вас наявними стандартними конвеєрами рендера. Якщо наявні стандартні конвеєри рендера не відповідають вашим потребам, вам потрібен власний конвеєр рендера.

Перш ніж перейти до власних конвеєрів рендера, подивімося на стандартний рендер.

## Фази вилучення та малювання {#the-extraction-and-drawing-phases}

Як згадувалося в [концепціях рендера](./basic-concepts), останні оновлення Minecraft працюють над розділенням рендера на дві фази: «вилучення» та «малювання».

Усі дані, необхідні для рендера, збираються під час фази «вилучення». Це включає, наприклад, запис у буферизований конструктор. Запис вершин у буферизований конструктор через `buffer.addVertex` є частиною фази «вилучення». Зауважте, що попри те, що багато методів мають префікс `draw` або `render`, їх слід викликати під час фази «вилучення». Ви повинні додати всі елементи, які ви хочете рендерити на цьому етапі.

Після завершення фази «вилучення» починається фаза «малювання», і створено буферизований конструктор. Під час цієї фази буферизований конструктор промальовування на екрані. Кінцева мета цього розділення «вилучення» та «малювання» полягає в тому, щоб дозволити малювати попередній кадр паралельно з вилученням наступного кадру, покращуючи продуктивність.

Тепер, пам’ятаючи про ці дві фази, подивімось, як створити власний конвеєр рендера.

## Власні конвеєри рендера {#custom-render-pipelines}

Скажімо, ми хочемо рендерити маршрутні точки, які мають з’являтися крізь стіни. Найближчим стандартним конвеєром для цього буде `RenderPipelines#DEBUG_FILLED_BOX`, але він не буде рендеритися через стіни, тому нам знадобиться спеціальний конвеєр рендера.

### Визначення власного конвеєра рендера {#defining-a-custom-render-pipeline}

Ми визначаємо власний конвеєр рендера в класі:

@[code lang=java transcludeWith=:::custom-pipelines:define-pipeline](@/reference/latest/src/client/java/com/example/docs/rendering/CustomRenderPipeline.java)

### Фаза вилучення {#extraction-phase}

Спочатку ми реалізуємо фазу «вилучення». Ми можемо викликати цей метод під час фази «вилучення», щоб додати маршрутну точку для рендера.

@[code lang=java transcludeWith=:::custom-pipelines:extraction-phase](@/reference/latest/src/client/java/com/example/docs/rendering/CustomRenderPipeline.java)

Зауважте, що розмір, який використовується в конструкторі `BufferAllocator`, залежить від конвеєра рендера, який ви використовуєте. У нашому випадку це `RenderType.SMALL_BUFFER_SIZE`.

Якщо ви хочете рендерити кілька маршрутних точок, викликайте цей метод кілька разів. Переконайтеся, що ви робите це під час фази «вилучення», ПЕРЕД початком фази «малювання», на якій будується конструктор буферів.

### Стани рендера {#render-states}

Зауважте, що у наведеному вище коді ми зберігаємо `BufferBuilder` у полі. Це тому, що нам це потрібно на етапі «малювання». У цьому випадку `BufferBuilder` — це наш «стан рендера» або «вилучені дані». Якщо вам потрібні додаткові дані під час фази «малювання», вам слід створити спеціальний клас стану рендера для зберігання `BufferedBuilder` і будь-яких додаткових даних рендера, які вам потрібні.

### Фаза малювання {#drawing-phase}

Тепер ми реалізуємо етап «малювання». Це слід викликати після того, як усі маршрутні точки, які ви хочете рендерити, були додані до `BufferBuilder` під час фази «вилучення».

@[code lang=java transcludeWith=:::custom-pipelines:drawing-phase](@/reference/latest/src/client/java/com/example/docs/rendering/CustomRenderPipeline.java)

### Очищення {#cleaning-up}

Нарешті, нам потрібно очистити ресурси, коли ігровий рендер закінчено. `GameRenderer#close` має викликати цей метод, і для цього вам наразі потрібно вставити в `GameRenderer#close` за допомогою міксина.

@[code lang=java transcludeWith=:::custom-pipelines:clean-up](@/reference/latest/src/client/java/com/example/docs/rendering/CustomRenderPipeline.java)

@[code lang=java](@/reference/latest/src/client/java/com/example/docs/mixin/client/GameRendererMixin.java)

### Остаточний код {#final-code}

Об'єднавши всі описані вище кроки, ми отримаємо простий клас, який рендерить маршрутну точку на `(0, 100, 0)` через стіни.

@[code lang=java](@/reference/latest/src/client/java/com/example/docs/rendering/CustomRenderPipeline.java)

Не забудьте також про `GameRendererMixin`! Ось результат:

![Маршрутну точку видко крізь стіни](/assets/develop/rendering/world-rendering-custom-render-pipeline-waypoint.png)
