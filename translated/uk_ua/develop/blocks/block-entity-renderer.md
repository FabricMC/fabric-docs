---
title: Промальовування блоку-сутності
description: Дізнайтеся, як покращити промальовування за допомогою промальовування блоку-сутності.
authors:
  - natri0
---

Іноді використання формату моделі Minecraft недостатньо. Якщо вам потрібно додати динамічне промальовування до візуальних елементів вашого блоку, вам потрібно буде використовувати `BlockEntityRenderer`.

Наприклад, нумо зробимо так, щоб блок лічильника зі [статті про блокові-сутностей](../blocks/block-entities) показував кількість натискань у зверху.

## Створення BlockEntityRenderer {#creating-a-blockentityrenderer}

Для початку, нам треба створити `BlockEntityRenderer` для `CounterBlockEntity`.

Створюючи `BlockEntityRenderer` для `CounterBlockEntity`, важливо помістити клас у відповідний вихідний набір, наприклад `src/client/`, якщо ваш проєкт використовує розділені вихідні набори для клієнта та сервера. Доступ до пов’язаних із промальовуванням класів безпосередньо у вихідному наборі `src/main/` небезпечний, оскільки ці класи можуть бути завантажені на сервер.

@[code transcludeWith=:::1](@/reference/latest/src/client/java/com/example/docs/rendering/blockentity/CounterBlockEntityRenderer.java)

Новий клас має конструктор із `BlockEntityRendererFactory.Context` як параметр. У `Context` є кілька корисних штук промальовування, наприклад `ItemRenderer` або `TextRenderer`.
Крім того, включивши такий конструктор, стає можливим використовувати конструктор як сам функціональний інтерфейс `BlockEntityRendererFactory`:

@[code transcludeWith=:::1](@/reference/latest/src/client/java/com/example/docs/FabricDocsBlockEntityRenderer.java)

Ви маєте зареєструвати промальовування блокових сутностей у своєму класі `ClientModInitializer`.

`BlockEntityRendererFactory` — це реєстр, який зіставляє кожен `BlockEntityType` зі спеціальним кодом відтворення на відповідний `BlockEntityRenderer`.

## Малювання на блоках {#drawing-on-blocks}

Тепер, коли у нас є промальовування, ми можемо малювати. Метод `render` викликається кожним кадром, і саме в ньому відбувається магія промальовування.

### Пересування {#moving-around}

По-перше, нам потрібно змістити та повернути текст так, щоб він знаходився вище блоку.

:::info
Як випливає з назви, `MatrixStack` є _стосом_, що означає, що ви можете надсилати та витягувати перетворення.
Гарне емпіричне правило полягає в тому, щоб додати новий блок на початку методу `render` і відкрити його в кінці, щоб промальовування одного блоку не впливав на інші.

Більше інформації про `MatrixStack` можна знайти в [статті про базові концепції промальовування](../rendering/basic-concepts).
:::

Щоб полегшити розуміння необхідних перекладів і поворотів, візуалізуємо їх. На цьому зображенні зелений блок – це місце, де буде намальовано текст, за замовчуванням у найдальшій нижній лівій точці блоку:

![Позиція промальовування за замовчуванням](/assets/develop/blocks/block_entity_renderer_1.png)

Отже, спочатку нам потрібно перемістити текст наполовину блоку по осях X і Z, а потім перемістити його вгору до верхньої частини блоку по осі Y:

![Зелений блок у верхній центральній точці](/assets/develop/blocks/block_entity_renderer_2.png)

Це робиться за допомогою одного виклику `translate`:

```java
matrices.translate(0.5, 1, 0.5);
```

Ось і _переклад_ зроблено, _обертання_ і _масштаб_ залишаються.

За замовчуванням текст малюється на площині X-Y, тому нам потрібно повернути його на 90 градусів навколо осі X, щоб він був спрямований вгору на площині X-Z:

![Зелений блок у верхній центральній точці, спрямований догори] (/assets/develop/blocks/block_entity_renderer_3.png)

`MatrixStack` не має функції `rotate`, натомість нам потрібно використовувати `multiply` і `RotationAxis.POSITIVE_X`:

```java
matrices.multiply(RotationAxis.POSITIVE_X.rotationDegrees(90));
```

Тепер текст у правильному положенні, але він завеликий. `BlockEntityRenderer` промальовує весь блок на куб `[-0.5, 0.5]`, тоді як `TextRenderer` використовує координати Y `[0, 9]`. Таким чином, нам потрібно зменшити його в 18 разів:

```java
matrices.scale(1/18f, 1/18f, 1/18f);
```

Тепер усе перетворення виглядає так:

@[code transcludeWith=:::2](@/reference/latest/src/client/java/com/example/docs/rendering/blockentity/CounterBlockEntityRenderer.java)

### Малювання тексту {#drawing-text}

Як згадувалося раніше, `Context`, переданий у конструктор нашого промальовування, має `TextRenderer`, який ми можемо використовувати для малювання тексту. Для цього прикладу ми збережемо його в полі.

`TextRenderer` має методи для вимірювання тексту (`getWidth`), що корисно для центрування, і для його малювання (`draw`).

@[code transcludeWith=:::3](@/reference/latest/src/client/java/com/example/docs/rendering/blockentity/CounterBlockEntityRenderer.java)

Метод `draw` приймає багато параметрів, але найважливіші з них:

- `Text` (або `String`) для малювання;
- його координати `x` і `y`;
- значення 'кольору' RGB;
- `Matrix4f`, що описує, як його слід трансформувати (щоб отримати один із `MatrixStack`, ми можемо використати `.peek().getPositionMatrix()`, щоб отримати `Matrix4f` для самого верхнього запису).

І після всієї цієї роботи ось результат:

![Блок лічильника з числом зверху](/assets/develop/blocks/block_entity_renderer_4.png)
