---
title: Події
description: Посібник по тому, як використовувати події, надані Fabric API.
authors:
  - Daomephsta
  - dicedpixels
  - Draylar
  - JamiesWhiteShirt
  - Juuxel
  - liach
  - mkpoli
  - natanfudge
  - PhoenixVX
  - SolidBlock-cn
  - YanisBft
authors-nogithub:
  - stormyfabric
---

API Fabric надає систему, яка дозволяє модам реагувати на дії або випадки, які також визначаються як _події_, що відбуваються в грі.

Події — це хуки, які задовольняють звичайні сценарії використання та/або забезпечують покращену сумісність і продуктивність між модами, які підключаються до тих самих областей коду. Використання подій часто замінює використання міксинів.

API Fabric надає події для важливих областей у кодовій базі Minecraft, до яких можуть бути зацікавлені кілька хуків.

Події представлені екземплярами `net.fabricmc.fabric.api.event.Event`, які зберігають і викликають _callbacks_. Часто існує один екземпляр події для зворотного виклику, який зберігається в статичному полі `EVENT` інтерфейсу зворотного виклику, але існують також інші шаблони. Наприклад, `ClientTickEvents` групує кілька пов’язаних подій разом.

## Зворотний виклик {#callbacks}

Зворотний виклик — це фрагмент коду, який передається як аргумент події. Коли подія ініціюється грою, переданий фрагмент коду буде виконано.

### Інтерфейс зворотного виклику {#callback-interfaces}

Кожна подія має відповідний інтерфейс зворотного виклику, умовно названий `<EventName>Callback`. Зворотні виклики реєструються шляхом виклику методу `register()` для екземпляра події з екземпляром інтерфейсу зворотного виклику як аргументу.

Усі інтерфейси зворотного виклику подій, надані Fabric API, можна знайти в пакеті `net.fabricmc.fabric.api.event`.

## Прослуховування подій {#listening-to-events}

У цьому прикладі реєструється `AttackBlockCallback`, щоб завдати шкоди гравцеві, коли він потрапляє в блоки, з яких не випадає предмет під час видобутку вручну.

@[code lang=java transcludeWith=:::1](@/reference/latest/src/main/java/com/example/docs/event/FabricDocsReferenceEvents.java)

### Додавання предметів до наявних таблиць здобичі {#adding-items-to-existing-loot-tables}

Іноді ви можете додати предмети до таблиць здобичі. Наприклад, додавання вашої здобичі до ванілльного блоку або сутності.

Найпростіше рішення, заміна файлу таблиці здобичі, може зламати інші моди. А якщо вони захочуть змінити і їх? Ми розглянемо, як можна додавати предмети до таблиць здобичі, не перевизначаючи таблицю.

Ми додамо яйця до таблиці здобичі вугільної руди.

#### Прослуховування завантаження таблиці здобичі {#listening-to-loot-table-loading}

API Fabric має подію, яка запускається під час завантаження таблиць здобичі, `LootTableEvents.MODIFY`. Ви можете зареєструвати зворотний виклик для нього в [ініціалізаторі мода](./getting-started/project-structure#entrypoints). Давайте також перевіримо, чи поточна таблиця здобичі є таблицею здобичі вугільної руди.

@[code lang=java transclude={38-40}](@/reference/latest/src/main/java/com/example/docs/event/FabricDocsReferenceEvents.java)

#### Додавання предметів до таблиці здобичі {#adding-items-to-the-loot-table}

У таблицях здобичі предмети зберігаються в _записах пулу здобичі_, а записи зберігаються в _пулах здобичі_. Щоб додати предмет, нам потрібно буде додати пул із записом предмета до таблиці здобичі.

Ми можемо створити пул за допомогою `LootPool#builder` і додати його до таблиці здобичі.

У нашому пулі також немає елементів, тому ми зробимо запис про елемент за допомогою `ItemEntry#builder` і додамо його до пулу.

@[code highlight={6-7} transcludeWith=:::2](@/reference/latest/src/main/java/com/example/docs/event/FabricDocsReferenceEvents.java)

## Власні події {#custom-events}

Деякі області гри не мають хуків, наданих Fabric API, тому ви можете використовувати міксин або створити власну подію.

Ми розглянемо створення події, яка запускається, коли вівцю стрижуть. Процес створення події:

- Створення інтерфейсу зворотного виклику події
- Запуск події з міксину
- Створення тестової реалізації

### Створення інтерфейсу зворотного виклику події {#creating-the-event-callback-interface}

Інтерфейс зворотного виклику описує, що має бути реалізоване слухачами подій, які слухатимуть вашу подію. Інтерфейс зворотного виклику також описує, як подія буде викликана з нашого міксину. Традиційно розміщувати об’єкт `Event` як поле в інтерфейсі зворотного виклику, яке ідентифікуватиме нашу фактичну подію.

Для нашої реалізації `Event` ми виберемо використання події на основі масиву. Масив міститиме всі слухачі подій, які прослуховують подію.

Наша реалізація буде викликати слухачі подій по порядку, доки один із них не поверне `ActionResult.PASS`. Це означає, що слухач може сказати «_скасувати це_», «_затвердити це_» або «_не хвилюйтеся, залиште це наступному слухачу події_», використовуючи його значення, що повертається.

Використання `ActionResult` як значення, що повертається, є звичайним способом змусити обробники подій співпрацювати таким чином.

Вам потрібно буде створити інтерфейс, який має екземпляр `Event` і метод для реалізації відповіді. Основні налаштування для зворотного виклику стрижки овець:

@[code lang=java transcludeWith=:::](@/reference/latest/src/main/java/com/example/docs/event/SheepShearCallback.java)

Розгляньмо це глибше. Коли виклик викликається, ми повторюємо всі слухачі:

@[code lang=java transclude={21-22}](@/reference/latest/src/main/java/com/example/docs/event/SheepShearCallback.java)

Потім ми викликаємо наш метод (у цьому випадку `interact`) для слухача, щоб отримати його відповідь:

@[code lang=java transclude={33-33}](@/reference/latest/src/main/java/com/example/docs/event/SheepShearCallback.java)

Якщо слухач каже, що ми повинні скасувати (`ActionResult.FAIL`) або повністю завершити (`ActionResult.SUCCESS`), функція зворотного виклику повертає результат і завершує цикл. `ActionResult.PASS` переходить до наступного слухача, і в більшості випадків має завершуватися успішно, якщо більше не зареєстровано слухачів:

@[code lang=java transclude={25-30}](@/reference/latest/src/main/java/com/example/docs/event/SheepShearCallback.java)

Ми можемо додати коментарі Javadoc у верхній частині класів зворотного виклику, щоб документувати, що робить кожен `ActionResult`. У нашому випадку це може бути:

@[code lang=java transclude={9-16}](@/reference/latest/src/main/java/com/example/docs/event/SheepShearCallback.java)

### Запуск події з міксину {#triggering-the-event-from-a-mixin}

Тепер у нас є основна структура подій, але нам потрібно його запустити. Оскільки ми хочемо, щоб подія викликалася, коли гравець намагається підстригти вівцю, ми викликаємо подію `invoker` у `SheepEntity#interactMob`, коли викликається `sheared()` (тобто вівцю можна стригти, якщо гравець тримає ножиці):

@[code lang=java transcludeWith=:::](@/reference/latest/src/main/java/com/example/docs/mixin/event/SheepEntityMixin.java)

### Створення тестової реалізації {#creating-a-test-implementation}

Тепер нам потрібно перевірити нашу подію. Ви можете зареєструвати слухача у своєму методі ініціалізації (або в іншій області, якщо хочете) і додати туди спеціальну логіку. Ось приклад, коли замість вовни випадає діамант:

@[code lang=java transcludeWith=:::3](@/reference/latest/src/main/java/com/example/docs/event/FabricDocsReferenceEvents.java)

Якщо ви входите в гру і стрижете вівцю, замість вовни повинен випасти діамант.
