---
title: Пользовательские компоненты данных
description: Узнайте, как добавлять пользовательские данные к вашим товарам, используя новую систему компонентов 1.20.5.
authors:
  - Romejanic
---

# Пользовательские компоненты данных {#custom-data-components}

По мере того как ваши элементы становятся более сложными, вам может потребоваться хранить специальные данные, связанные с каждым элементом. Игра позволяет хранить постоянные данные в `ItemStack`, и начиная с версии 1.20.5 мы делаем это с помощью **Компонентов данных**.

Компоненты данных заменяют данные NBT из предыдущих версий структурированными типами данных, которые можно применять к `ItemStack` для хранения постоянных данных об этом стеке. Компоненты данных имеют пространство имен, что означает, что мы можем реализовать собственные компоненты данных для хранения пользовательских данных о `ItemStack` и доступа к ним позже. Полный список компонентов данных vanilla можно найти на этой [странице вики Minecraft](https://minecraft.wiki/w/Data_component_format#List_of_components).

Наряду с регистрацией пользовательских компонентов на этой странице рассматривается общее использование API компонентов, которое также применимо к ванильным компонентам. Вы можете просмотреть и получить доступ к определениям всех ванильных компонентов в классе `DataComponentTypes`.

## Регистрация компонента {#registering-a-component}

Как и все остальное в вашем моде, вам необходимо зарегистрировать свой пользовательский компонент с помощью `ComponentType`. Этот тип компонента принимает универсальный аргумент, содержащий тип значения вашего компонента. Мы более подробно рассмотрим это далее, когда будем рассматривать [базовые](#basic-data-components) и [расширенные](#advanced-data-components) компоненты.

Выберите подходящий класс для размещения этого кода. В этом примере мы создадим новый пакет с именем `component` и класс, содержащий все типы наших компонентов, с именем `ModComponents`. Обязательно вызовите `ModComponents.initialize()` в инициализаторе мода.

@[code transcludeWith=::1](@/reference/latest/src/main/java/com/example/docs/component/ModComponents.java)

Это базовый шаблон для регистрации типа компонента:

```java
public static final ComponentType<?> MY_COMPONENT_TYPE = Registry.register(
    Registries.DATA_COMPONENT_TYPE,
    Identifier.of(FabricDocsReference.MOD_ID, "my_component"),
    ComponentType.<?>builder().codec(null).build()
);
```

Здесь есть несколько вещей, на которые стоит обратить внимание. В первой и четвертой строках вы можете увидеть `?`. Он будет заменен типом значения вашего компонента. Мы скоро это заполним.

Во-вторых, вы должны предоставить `Идентификатор`, содержащий предполагаемый идентификатор вашего компонента. Это пространство имен с идентификатором вашего мода.

Наконец, у нас есть `ComponentType.Builder`, который создает фактический экземпляр `ComponentType` и регистрируется. Здесь содержится еще одна важная деталь, которую нам нужно будет обсудить: `Codec` вашего компонента. В настоящее время это поле пустое, но мы скоро его заполним.

## Базовые компоненты данных {#basic-data-components}

Базовые компоненты данных (например, `minecraft:damage`) состоят из одного значения данных, например `int`, `float`, `boolean` или `String`.

В качестве примера давайте создадим значение `Integer`, которое будет отслеживать, сколько раз игрок щелкнул правой кнопкой мыши, удерживая наш предмет. Давайте обновим регистрацию нашего компонента следующим образом:

@[code transcludeWith=::2](@/reference/latest/src/main/java/com/example/docs/component/ModComponents.java)

Вы можете видеть, что теперь мы передаем `<Integer>` в качестве нашего универсального типа, указывая, что этот компонент будет сохранен как одно значение `int`. В качестве нашего кодека мы используем предоставленный кодек `Codec.INT`. Для таких простых компонентов, как этот, можно обойтись использованием базовых кодеков, но для более сложных сценариев может потребоваться специальный кодек (об этом мы кратко поговорим позже).

Если вы запустите игру, вы сможете ввести такую ​​команду:

![/give command showing the custom component](/assets/develop/items/custom_component_0.png)

При выполнении команды вы должны получить элемент, содержащий компонент. Однако в настоящее время мы не используем наш компонент для каких-либо полезных целей. Давайте начнем с прочтения значения компонента таким образом, чтобы мы могли его увидеть.

## Значение компонента чтения {#reading-component-value}

Давайте добавим новый элемент, который будет увеличивать счетчик каждый раз, когда по нему щелкают правой кнопкой мыши. Вам следует прочитать страницу [Взаимодействие с пользовательскими элементами](./custom-item-interactions), где описаны методы, которые мы будем использовать в этом руководстве.

@[code transcludeWith=::1](@/reference/latest/src/main/java/com/example/docs/item/custom/CounterItem.java)

Не забудьте, как обычно, зарегистрировать элемент в классе `ModItems`.

```java
public static final Item COUNTER = register(new CounterItem(
    new Item.Settings()
), "counter");
```

Мы добавим код подсказки, чтобы отображать текущее значение количества кликов при наведении курсора на наш предмет в инвентаре. Мы можем использовать метод `get()` в нашем `ItemStack`, чтобы получить значение нашего компонента следующим образом:

```java
int clickCount = stack.get(ModComponents.CLICK_COUNT_COMPONENT);
```

Это вернет текущее значение компонента как тип, который мы определили при регистрации нашего компонента. Затем мы можем использовать это значение для добавления записи всплывающей подсказки. Добавьте эту строку в метод `appendTooltip` в классе `CounterItem`:

```java
public void appendTooltip(ItemStack stack, TooltipContext context, List<Text> tooltip, TooltipType type) {
    int count = stack.get(ModComponents.CLICK_COUNT_COMPONENT);
    tooltip.add(Text.translatable("item.fabric-docs-reference.counter.info", count).formatted(Formatting.GOLD));
}
```

Не забудьте обновить свой языковой файл (`/assets/<mod id>/lang/en_us.json`) и добавить в него следующие две строки:

```json
{
    "item.fabric-docs-reference.counter": "Counter",
    "item.fabric-docs-reference.counter.info": "Used %1$s times",
}
```

Запустите игру и выполните эту команду, чтобы получить новый предмет счетчик со значением 5.

```mcfunction
/give @p fabric-docs-reference:counter[fabric-docs-reference:click_count=5]
```

При наведении курсора на этот предмет в инвентаре вы увидите количество, отображаемое во всплывающей подсказке!

![Подсказка с надписью «Использовано 5 раз»](/assets/develop/items/custom_component_1.png)

Однако если вы дадите себе новый предмет Counter _без_ пользовательского компонента, игра вылетит при наведении курсора на предмет в инвентаре. В отчете о сбое вы должны увидеть такую ​​ошибку:

```log
java.lang.NullPointerException: Cannot invoke "java.lang.Integer.intValue()" because the return value of "net.minecraft.item.ItemStack.get(net.minecraft.component.ComponentType)" is null
        at com.example.docs.item.custom.CounterItem.appendTooltip(LightningStick.java:45)
        at net.minecraft.item.ItemStack.getTooltip(ItemStack.java:767)
```

As expected, since the `ItemStack` doesn't currently contain an instance of our custom component, calling `stack.get()` with our component type will return `null`.

Для решения этой проблемы мы можем использовать три решения.

### Установка значения компонента по умолчанию {#setting-default-value}

Когда вы регистрируете свой элемент и передаете объект `Item.Settings` в конструктор элемента, вы также можете предоставить список компонентов по умолчанию, которые применяются ко всем новым элементам. Если вернуться к нашему классу `ModItems`, где мы регистрируем `CounterItem`, мы можем добавить значение по умолчанию для нашего пользовательского компонента. Добавьте это, чтобы для новых элементов отображалось количество «0».

@[code transcludeWith=::_13](@/reference/latest/src/main/java/com/example/docs/item/ModItems.java)

При создании нового элемента он автоматически применит наш пользовательский компонент с заданным значением.

:::warning
Используя команды, можно удалить компонент по умолчанию из `ItemStack`. Вам следует обратиться к следующим двум разделам, чтобы правильно обработать ситуацию, когда компонент отсутствует в вашем изделии.
:::

### Чтение со значением по умолчанию {#reading-default-value}

Кроме того, при чтении значения компонента мы можем использовать метод `getOrDefault()` нашего объекта `ItemStack`, чтобы вернуть указанное значение по умолчанию, если компонент отсутствует в стеке. Это защитит от любых ошибок, возникающих из-за отсутствия какого-либо компонента. Мы можем настроить код нашей подсказки следующим образом:

```java
int clickCount = stack.getOrDefault(ModComponents.CLICK_COUNT_COMPONENT, 0);
```

Как видите, этот метод принимает два аргумента: тип нашего компонента, как и раньше, и значение по умолчанию, которое будет возвращаться, если компонент отсутствует.

### Проверка существования компонента {#checking-if-component-exists}

Вы также можете проверить наличие определенного компонента в `ItemStack`, используя метод `contains()`. Он принимает тип компонента в качестве аргумента и возвращает `true` или `false` в зависимости от того, содержит ли стек этот компонент.

```java
boolean exists = stack.contains(ModComponents.CLICK_COUNT_COMPONENT);
```

### Исправление ошибки {#fixing-the-error}

Мы выберем третий вариант. Поэтому наряду с добавлением значения компонента по умолчанию мы также проверим, присутствует ли компонент в стеке, и покажем подсказку только в том случае, если это так.

@[code transcludeWith=::3](@/reference/latest/src/main/java/com/example/docs/item/custom/CounterItem.java)

Запустите игру снова и наведите курсор на предмет без компонента. Вы должны увидеть надпись «Использовано 0 раз», и игра больше не будет вылетать.

![Подсказка с сообщением «Использовано 0 раз»](/assets/develop/items/custom_component_2.png)

Попробуйте создать свой счетчик, удалив наш пользовательский компонент. Для этого можно использовать следующую команду:

```mcfunction
/give @p fabric-docs-reference:counter[!fabric-docs-reference:click_count]
```

При наведении курсора на этот элемент подсказка должна отсутствовать.

![Встречный элемент без подсказки](/assets/develop/items/custom_component_7.png)

## Обновление значения компонента {#setting-component-value}

Теперь попробуем обновить значение нашего компонента. Мы собираемся увеличивать количество кликов каждый раз, когда используем наш элемент Counter. Чтобы изменить значение компонента в `ItemStack`, мы используем метод `set()` следующим образом:

```java
stack.set(ModComponents.CLICK_COUNT_COMPONENT, newValue);
```

Он принимает тип нашего компонента и значение, которое мы хотим ему присвоить. В данном случае это будет наше новое количество кликов. Этот метод также возвращает старое значение компонента (если оно присутствует), что может быть полезно в некоторых ситуациях. Например:

```java
int oldValue = stack.set(ModComponents.CLICK_COUNT_COMPONENT, newValue);
```

Давайте настроим новый метод `use()` для считывания старого количества кликов, увеличения его на единицу, а затем установки обновленного количества кликов.

@[code transcludeWith=::2](@/reference/latest/src/main/java/com/example/docs/item/custom/CounterItem.java)

Теперь попробуйте запустить игру и щелкнуть правой кнопкой мыши, держа в руке предмет Counter. Если вы откроете свой инвентарь и снова посмотрите на предмет, вы увидите, что показатель использования увеличился пропорционально количеству кликов по нему.

![Подсказка с надписью «Использовано 8 раз»](/assets/develop/items/custom_component_3.png)

## Удаление значения компонента {#removing-component-value}

Вы также можете удалить компонент из `ItemStack`, если он больше не нужен. Это делается с помощью метода `remove()`, который принимает тип вашего компонента.

```java
stack.remove(ModComponents.CLICK_COUNT_COMPONENT);
```

Этот метод также возвращает значение компонента до его удаления, поэтому его можно использовать следующим образом:

```java
int oldCount = stack.remove(ModComponents.CLICK_COUNT_COMPONENT);
```

## Расширенные компоненты данных {#advanced-data-components}

Возможно, вам придется хранить несколько атрибутов в одном компоненте. В качестве простого примера компонент `minecraft:food` хранит несколько значений, связанных с едой, таких как `nutrition`, `saturation`, `eat_seconds` и другие. В этом руководстве мы будем называть их «композитными» компонентами.

Для составных компонентов необходимо создать класс `record` для хранения данных. Это тип, который мы зарегистрируем в нашем типе компонента, и то, что мы будем читать и записывать при взаимодействии с `ItemStack`. Начнем с создания нового класса записи в пакете `component`, который мы создали ранее.

```java
public record MyCustomComponent() {
}
```

Обратите внимание, что после имени класса стоят скобки. Здесь мы определяем список свойств, которые должен иметь наш компонент. Давайте добавим число с плавающей точкой и логическое значение с именами `температура` и `сожженный` соответственно.

@[code transcludeWith=::1](@/reference/latest/src/main/java/com/example/docs/component/MyCustomComponent.java)

Поскольку мы определяем пользовательскую структуру данных, для нашего варианта использования не будет готового `Кодека`, как в случае с [базовым компонентом](#basic-data-components). Это значит, что нам придется создать собственный кодек. Давайте определим его в нашем классе записи, используя `RecordCodecBuilder`, на который мы сможем ссылаться после регистрации компонента. Более подробную информацию об использовании `RecordCodecBuilder` можно найти в [этом разделе страницы Кодеки](../codecs#merging-codecs-for-record-like-classes).

@[code transcludeWith=::2](@/reference/latest/src/main/java/com/example/docs/component/MyCustomComponent.java)

Вы можете видеть, что мы определяем список пользовательских полей на основе примитивных типов `Codec`. Однако мы также сообщаем ей, как называются наши поля, используя `fieldOf()`, а затем используем `forGetter()`, чтобы сообщить игре, какой атрибут нашей записи следует заполнить.

Вы также можете определить необязательные поля, используя `optionalFieldOf()` и передав значение по умолчанию в качестве второго аргумента. Любые поля, не отмеченные как необязательные, будут обязательными при настройке компонента с помощью `/give`, поэтому обязательно отметьте все необязательные аргументы как таковые при создании кодека.

Наконец, мы вызываем `apply()` и передаем конструктор нашей записи. Более подробную информацию о создании кодеков и более сложных вариантах использования можно найти на странице [Кодеки](../codecs).

Регистрация составного компонента аналогична предыдущей. Мы просто передаем наш класс записи как универсальный тип, а наш пользовательский `Codec` — в метод `codec()`.

@[code transcludeWith=::3](@/reference/latest/src/main/java/com/example/docs/component/ModComponents.java)

Теперь начинайте игру. Попробуйте применить компонент с помощью команды `/give`. Значения составных компонентов передаются как объект, заключенный в `{}`. Если вы поставите пустые фигурные скобки, вы увидите сообщение об ошибке, сообщающее, что требуемый ключ `temperature` отсутствует.

![Дайте команду, показывающую отсутствующий ключ "температура"](/assets/develop/items/custom_component_4.png)

Добавьте значение температуры к объекту, используя синтаксис `temperature:8.2`. При желании можно также передать значение для `burnt`, используя тот же синтаксис, но либо `true`, либо `false`. Теперь вы должны увидеть, что команда действительна и может предоставить вам элемент, содержащий компонент.

![Верная команда give, показывающая оба свойства](/assets/develop/items/custom_component_5.png)

### Получение, настройка и удаление дополнительных компонентов {#getting-setting-removing-advanced-comps}

Использование компонента в коде такое же, как и раньше. Использование `stack.get()` вернет экземпляр вашего класса `record`, который затем можно использовать для чтения значений. Поскольку записи доступны только для чтения, вам потребуется создать новый экземпляр записи, чтобы обновить значения.

```java
// read values of component
MyCustomComponent comp = stack.get(ModComponents.MY_CUSTOM_COMPONENT);
float temp = comp.temperature();
boolean burnt = comp.burnt();

// set new component values
stack.set(ModComponents.MY_CUSTOM_COMPONENT, new MyCustomComponent(8.4f, true));

// check for component
if (stack.contains(ModComponents.MY_CUSTOM_COMPONENT)) {
    // do something
}

// remove component
stack.remove(ModComponents.MY_CUSTOM_COMPONENT);
```

Вы также можете задать значение по умолчанию для составного компонента, передав объект компонента в `Item.Settings`. Например:

```java
public static final Item COUNTER = register(new CounterItem(
    new Item.Settings().component(ModComponents.MY_CUSTOM_COMPONENT, new MyCustomComponent(0.0f, false))
), "counter");
```

Теперь вы можете хранить пользовательские данные в `ItemStack`. Используйте ответственно!

![Элемент, показывающий подсказки для количества кликов, температуры и сожженного](/assets/develop/items/custom_component_6.png)
