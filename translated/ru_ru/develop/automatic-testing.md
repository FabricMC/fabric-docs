---
title: Автоматизированное тестирование
description: Руководство по написанию автоматических тестов с помощью Fabric Loader JUnit.
authors:
  - kevinthegreat1
---

# Автоматизированное тестирование {#automated-testing}

На этой странице объясняется, как написать код для автоматического тестирования частей вашего мода. Существует два способа автоматического тестирования вашего мода: модульные тесты с помощью Fabric Loader JUnit или игровые тесты с помощью фреймворка Gametest из Minecraft.

Модульные тесты следует использовать для тестирования компонентов вашего кода, таких как методы и вспомогательные классы, в то время как игровые тесты запускают реальный клиент и сервер Minecraft для запуска ваших тестов, что делает их подходящими для тестирования функций и игрового процесса.

:::warning
В настоящее время данное руководство охватывает только модульное тестирование.
:::

## Модульное тестирование {#unit-testing}

Поскольку моддинг Minecraft основан на инструментах модификации байт-кода во время выполнения, таких как Mixin, простое добавление и использование JUnit обычно не работает. Вот почему Fabric предоставляет Fabric Loader JUnit — плагин JUnit, который позволяет проводить модульное тестирование в Minecraft.

### Настройка Fabric Loader JUnit {#setting-up-fabric-loader-junit}

Сначала нам необходимо добавить Fabric Loader JUnit в среду разработки. Добавьте следующее в блок зависимостей в `build.gradle`:

@[code lang=groovy transcludeWith=:::automatic-testing:1](@/reference/build.gradle)

Затем нам нужно указать Gradle использовать Fabric Loader JUnit для тестирования. Это можно сделать, добавив следующий код в `build.gradle`:

@[code lang=groovy transcludeWith=:::automatic-testing:2](@/reference/latest/build.gradle)

### Написание тестов {#writing-tests}

После перезагрузки Gradle вы будете готовы писать тесты.

Эти тесты пишутся так же, как и обычные тесты JUnit, с небольшой дополнительной настройкой, если вам нужно получить доступ к любому классу, зависящему от реестра, например `ItemStack`. Если вы знакомы с JUnit, можете перейти к разделу [Настройка реестров](#setting-up-registries).

#### Настройка вашего первого тестового класса {#setting-up-your-first-test-class}

Тесты пишутся в каталоге `src/test/java`.

Одним из правил именования является отражение структуры пакета тестируемого класса. Например, чтобы протестировать `src/main/java/com/example/docs/codec/BeanType.java`, вам нужно создать класс в `src/test/java/com/example/docs/codec/BeanTypeTest.java`. Обратите внимание, как мы добавили `Test` в конец имени класса. Это также позволяет легко получить доступ к методам и полям, закрытым для пакета.

Другое соглашение об именовании — наличие пакета `test`, например `src/test/java/com/example/docs/test/codec/BeanTypeTest.java`. Это предотвращает некоторые проблемы, которые могут возникнуть при использовании того же пакета, если вы используете модули Java.

После создания тестового класса используйте <kbd>⌘/CTRL</kbd><kbd>N</kbd>, чтобы вызвать меню «Создать». Выберите Test и начните вводить имя метода, обычно начинающееся с `test`. Выберите Test и начните вводить имя метода, обычно начинающееся с `test`. Нажмите <kbd>ENTER</kbd>, когда закончите. Дополнительные советы и рекомендации по использованию IDE см. в разделе [Советы и рекомендации IDE](./ide-tips-and-tricks#code-generation).

![Создание метода тестирования](/assets/develop/misc/automatic-testing/unit_testing_01.png)

Конечно, вы можете написать сигнатуру метода вручную, и любой метод экземпляра без параметров и с типом возвращаемого значения void будет идентифицирован как тестовый метод. В итоге у вас должно получиться следующее:

![Пустой метод тестирования с тестовыми индикаторами](/assets/develop/misc/automatic-testing/unit_testing_02.png)

Обратите внимание на зеленые стрелки индикаторы в желобе: вы можете легко запустить тест, щелкнув по ним. В качестве альтернативы ваши тесты будут запускаться автоматически для каждой сборки, включая сборки CI такие, как GitHub Actions. Если вы используете GitHub Actions, не забудьте прочитать [Настройка GitHub Actions](#setting-up-github-actions).

Теперь пришло время написать настоящий тестовый код. Вы можете утверждать условия, используя `org.junit.jupiter.api.Assertions`. Проверьте следующий тест:

@[code lang=java transcludeWith=:::automatic-testing:4](@/reference/latest/src/test/java/com/example/docs/codec/BeanTypeTest.java)

Объяснение того, что на самом деле делает этот код, см. в разделе [Кодеки](./codecs#registry-dispatch).

#### Настройка реестров {#setting-up-registries}

Отлично, первый тест сработал! Но подождите, второй тест не прошёл? В журналах мы получаем одну из следующих ошибок.

@[code lang=java transcludeWith=:::automatic-testing:5](@/reference/latest/src/test/java/com/example/docs/codec/BeanTypeTest.java)

Это происходит потому, что мы пытаемся получить доступ к реестру или классу, который зависит от реестра (или, в редких случаях, зависит от других классов Minecraft таких, как `SharedConstants`), но Minecraft не инициализирован. Нам нужно просто немного инициализировать его, чтобы реестры заработали. Просто добавьте следующий код в начало метода `beforeAll`.

@[code lang=java transcludeWith=:::automatic-testing:7](@/reference/latest/src/test/java/com/example/docs/codec/BeanTypeTest.java)

### Настройка действий GitHub {#setting-up-github-actions}

:::info
В этом разделе предполагается, что вы используете стандартный рабочий процесс GitHub Action, включенный в пример мода и в шаблон мода.
:::

Теперь ваши тесты будут запускаться для каждой сборки, включая сборки поставщиков непрерывной интеграции, таких как GitHub Actions. Но что делать, если сборка не удалась? Нам необходимо загрузить журналы как артефакт, чтобы мы могли просматривать отчеты об испытаниях.

Добавьте это в файл `.github/workflows/build.yml`, ниже шага `./gradlew build`.

```yaml
- name: Store reports
  if: failure()
  uses: actions/upload-artifact@v4
  with:
    name: reports
    path: |
      **/build/reports/
      **/build/test-results/
```
